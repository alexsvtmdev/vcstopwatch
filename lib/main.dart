import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:developer' as developer;
import 'package:flutter/material.dart';
import 'package:flutter_tts/flutter_tts.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:vosk_flutter_2/vosk_flutter_2.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:another_flushbar/flushbar.dart';
import 'package:path_provider/path_provider.dart';

// –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥ –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è/–æ—Ç–∫–ª—é—á–µ–Ω–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
// –î–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞ –º–æ–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å false, –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ ‚Äî true.
const bool kLoggingEnabled = true;

const Map<String, String> languageNames = {
  "en-us": "English",
  "ru": "Russian",
  "fr": "French",
  "de": "German",
  "es": "Spanish",
  "cn": "Chinese",
  "it": "Italian",
  "pt": "Portuguese",
  "nl": "Dutch",
  "uk": "Ukrainian",
  "ja": "Japanese",
  "ko": "Korean",
  "ar": "Arabic",
  "hi": "Hindi",
  "fa": "Farsi",
  "pl": "Polish",
  "cs": "Czech",
  "tr": "Turkish",
  "el-gr": "Greek",
  "tl-ph": "Filipino",
  "ca": "Catalan",
};

/// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∏–º–µ–Ω–∏ —è–∑—ã–∫–∞ –∏–∑ –ø—É—Ç–∏ –º–æ–¥–µ–ª–∏.
String extractLanguageNameFromModelPath(String path) {
  final regex = RegExp(r'(vosk-model(?:-small)?-)([a-z\-]+)(?:-[^/\\]*)?$');
  final match = regex.firstMatch(path.toLowerCase());
  if (match != null && match.groupCount >= 2) {
    final langCode = match.group(2)!;
    return languageNames[langCode] ?? langCode;
  }
  return "unknown";
}

/// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.
void appLog(
  String message, {
  String name = 'AppLog',
  int level = 0,
  DateTime? time,
  Object? error,
  StackTrace? stackTrace,
}) {
  if (kLoggingEnabled) {
    if (kReleaseMode) {
      // –í —Ä–µ–∂–∏–º–µ —Ä–µ–ª–∏–∑–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º print –¥–ª—è –≤—ã–≤–æ–¥–∞ –ª–æ–≥–æ–≤
      print('[$name] $message');
    } else {
      developer.log(
        message,
        name: name,
        level: level,
        time: time,
        error: error,
        stackTrace: stackTrace,
      );
    }
  }
}

/// –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –Ω–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç true, –µ—Å–ª–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –≤—ã–¥–∞–Ω–æ.
Future<bool> requestMicrophonePermission() async {
  final status = await Permission.microphone.status;
  if (status.isGranted) {
    appLog('üéôÔ∏è Microphone permission already granted.');
    return true;
  }
  final result = await Permission.microphone.request();
  if (result == PermissionStatus.granted) {
    appLog('‚úÖ Microphone permission granted.');
    return true;
  } else {
    appLog('‚ùå Microphone permission not granted: $result');
    return false;
  }
}

/// –ö–ª–∞—Å—Å, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–π –∑–∞–ø–∏—Å—å –∫—Ä—É–≥–∞.
class LapRecord {
  final int lapNumber;
  final Duration lapTime;
  final Duration overallTime;
  LapRecord({
    required this.lapNumber,
    required this.lapTime,
    required this.overallTime,
  });
}

/// –†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –≥–æ–ª–æ—Å–∞ —Å —Ñ–ª–∞–≥–æ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ–Ω –∫–æ–º–∞–Ω–¥–æ–π.
class VoiceCommandResult {
  final String text;
  final bool isCommand;
  VoiceCommandResult({required this.text, required this.isCommand});
}

/// –°–µ—Ä–≤–∏—Å –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥.
/// –û—Ç–≤–µ—á–∞–µ—Ç –∑–∞ –∑–∞–≥—Ä—É–∑–∫—É —è–∑—ã–∫–æ–≤–æ–π –º–æ–¥–µ–ª–∏, —Å–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç–µ–ª—è –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–Ω—ã–º —Å–µ—Ä–≤–∏—Å–æ–º.
class VoiceCommandService {
  final VoskFlutterPlugin _vosk = VoskFlutterPlugin.instance();
  final ModelLoader _modelLoader = ModelLoader();
  Model? model;
  Recognizer? recognizer;
  SpeechService? speechService;
  final _controller = StreamController<VoiceCommandResult>.broadcast();

  // –°–ø–∏—Å–æ–∫ —Å–ª–æ–≤ –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –∫–æ–º–∞–Ω–¥.
  static const List<String> commandWords = [
    "start",
    "go",
    "begin",
    "stop",
    "end",
    "pause",
    "reset",
    "clear",
    "restart",
    "renew",
    "resume",
    "lap",
    "split",
  ];

  // –°–ø–∏—Å–æ–∫ —Å–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Ä–∞—Å–ø–æ–∑–Ω–∞—é—Ç—Å—è, –Ω–æ –Ω–µ –≤—ã–∑—ã–≤–∞—é—Ç —Ä–µ–∞–∫—Ü–∏—é.
  static const List<String> ignoreWords = [
    "minute",
    "minutes",
    "seconds",
    "stopwatch",
    "zero",
    "completed",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "ten",
    "twenty",
    "thirty",
    "forty",
    "fifty",
    "circle",
  ];

  // grammarList ‚Äì –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ commandWords –∏ ignoreWords.
  List<String> get grammarList => [...commandWords, ...ignoreWords];

  Stream<VoiceCommandResult> get commandStream => _controller.stream;

  /// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å–µ—Ä–≤–∏—Å: –∑–∞–≥—Ä—É–∂–∞–µ—Ç –º–æ–¥–µ–ª—å, —Å–æ–∑–¥–∞–µ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç–µ–ª—å –∏,
  /// –µ—Å–ª–∏ initSpeechService==true, –∑–∞–ø—É—Å–∫–∞–µ—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å.
  Future<void> initialize({
    ValueNotifier<String>? loadingStatus,
    bool initSpeechService = true,
  }) async {
    const modelName = 'vosk-model-small-en-us-0.15';
    const sampleRate = 16000;

    try {
      loadingStatus?.value = "Initializing voice service...";
      final modelsList = await _modelLoader.loadModelsList();
      final modelDescription = modelsList.firstWhere(
        (m) => m.name == modelName,
      );

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –∑–∞–≥—Ä—É–∑–∫–∞ —è–∑—ã–∫–æ–≤–æ–π –º–æ–¥–µ–ª–∏.
      final dir = await getApplicationSupportDirectory();
      final modelFolder = Directory('${dir.path}/$modelName');
      final bool modelExists = await modelFolder.exists();
      final languageCode = extractLanguageNameFromModelPath(modelName);
      if (!modelExists) {
        loadingStatus?.value = "Downloading language: $languageCode";
        await Future.delayed(Duration(milliseconds: 10));
      }
      final modelPath = await _modelLoader.loadFromNetwork(
        modelDescription.url,
      );
      loadingStatus?.value = "Initializing voice service...";
      model = await _vosk.createModel(modelPath);
    } catch (e) {
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏.
      rethrow;
    }

    try {
      recognizer = await _vosk.createRecognizer(
        model: model!,
        sampleRate: sampleRate,
      );
      await recognizer!.setGrammar(grammarList);
    } catch (e) {
      rethrow;
    }

    // –ï—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä initSpeechService –∏—Å—Ç–∏–Ω–µ–Ω, –∑–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –º–∏–∫—Ä–æ—Ñ–æ–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞.
    if (initSpeechService) {
      await initializeSpeechService();
    }

    appLog(
      "VoiceCommandService fully initialized.",
      name: "VoiceCommandService",
    );
  }

  /// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å.
  Future<void> initializeSpeechService() async {
    try {
      if (Platform.isAndroid) {
        // –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä SpeechService.
        speechService = await _vosk.initSpeechService(recognizer!);
        speechService!.onResult().listen((result) {
          processResult(result);
        });
        appLog("Speech service initialized.", name: "VoiceCommandService");
      }
    } catch (e, stackTrace) {
      appLog(
        "Error initializing speech service: $e",
        name: "VoiceCommandService",
        stackTrace: stackTrace,
      );
      rethrow;
    }
  }

  /// –û—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç —Ä–µ—Å—É—Ä—Å—ã –º–∏–∫—Ä–æ—Ñ–æ–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞.
  /// –ï—Å–ª–∏ speechService –Ω–µ —Ä–∞–≤–µ–Ω null, –ø—ã—Ç–∞–µ—Ç—Å—è –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –µ–≥–æ –∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤ null.
  Future<void> freeSpeechService() async {
    if (speechService != null) {
      try {
        await speechService!.stop();
        // –ï—Å–ª–∏ —É speechService –µ—Å—Ç—å –º–µ—Ç–æ–¥ dispose(), –µ–≥–æ –º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å –∑–¥–µ—Å—å.
        // await speechService!.dispose();
      } catch (e, st) {
        appLog(
          "Error freeing speech service: $e",
          name: "VoiceCommandService",
          stackTrace: st,
        );
      }
      speechService = null;
    }
  }

  /// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç JSON-—Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –µ–≥–æ –≤ –ø–æ—Ç–æ–∫.
  void processResult(String resultJson) {
    appLog("Raw voice result: $resultJson", name: "VoiceCommandService");
    try {
      final result = jsonDecode(resultJson);
      if (result.containsKey('text')) {
        String recognized = result['text'].toLowerCase().trim();
        if (recognized.isEmpty) recognized = "-";
        bool isCommand = false;
        if (!ignoreWords.contains(recognized)) {
          for (var word in commandWords) {
            if (recognized.contains(word)) {
              isCommand = true;
              break;
            }
          }
        }
        _controller.add(
          VoiceCommandResult(text: recognized, isCommand: isCommand),
        );
        appLog(
          "Processed voice result: $recognized, isCommand: $isCommand",
          name: "VoiceCommandService",
        );
      }
    } catch (e) {
      appLog("Error processing voice result: $e", name: "VoiceCommandService");
    }
  }

  Future<void> startListening() async {
    if (speechService != null) {
      await speechService!.start();
      appLog("Voice recognition started.", name: "VoiceCommandService");
    }
  }

  Future<void> stopListening() async {
    if (speechService != null) {
      await speechService!.stop();
      appLog("Voice recognition stopped.", name: "VoiceCommandService");
    }
  }

  void dispose() {
    _controller.close();
  }
}

const bool kEnableSplashDelayForPromo =
    false; // –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ true –¥–ª—è —Ä–æ–ª–∏–∫–∞ —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π —Å–ø–ª–µ—à—Å–∫—Ä–∏–Ω–∞.

void main() async {
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–∏–≤—è–∑–∫–∏ —Å—Ä–∞–∑—É, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø—Ä–æ–±–ª–µ–º —Å –∑–æ–Ω–∞–º–∏.
  WidgetsFlutterBinding.ensureInitialized();
  final prefs = await SharedPreferences.getInstance();
  final immersiveEnabled = prefs.getBool('immersiveMode') ?? false;

  // –í–∫–ª—é—á–∞–µ–º immersive-—Ä–µ–∂–∏–º, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ (–ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º –≤ –Ω–∞—Å—Ç—Ä–π–æ–∫–∞—Ö)
  if (immersiveEnabled) {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);
  }

  // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –∑–∞–¥–µ—Ä–∂–∞—Ç—å —Å–ø–ª–µ—à-—ç–∫—Ä–∞–Ω
  if (kEnableSplashDelayForPromo) {
    WidgetsBinding.instance.deferFirstFrame();
  }

  // –ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫–∏ Flutter
  FlutterError.onError = (FlutterErrorDetails details) {
    appLog(
      "FlutterError: ${details.exception}",
      name: "FlutterError",
      stackTrace: details.stack,
    );
  };

  runZonedGuarded(
    () async {
      runApp(const MyApp());
      if (kEnableSplashDelayForPromo) {
        await Future.delayed(const Duration(seconds: 4));
        WidgetsBinding.instance.allowFirstFrame();
      }
    },
    (error, stackTrace) {
      appLog(
        "Unhandled error: $error",
        name: "runZonedGuarded",
        stackTrace: stackTrace,
      );
    },
  );
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'VoiceControl Stopwatch',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        brightness: Brightness.dark,
        scaffoldBackgroundColor: const Color(0xFF001F3F),
        appBarTheme: const AppBarTheme(backgroundColor: Color(0xFF001F3F)),
      ),
      home: const TimerPage(),
    );
  }
}

class TimerPage extends StatefulWidget {
  const TimerPage({super.key});
  @override
  TimerPageState createState() => TimerPageState();
}

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–∞–π–º–∞—É—Ç–æ–≤
const Duration kVoiceServiceTimeout = Duration(seconds: 60);
const Duration kVoicePermissionWaitTimeout = Duration(seconds: 15);

/// –ï—Å–ª–∏ kTreatDeniedAsFinal == true, —Ç–æ —Å—Ç–∞—Ç—É—Å PermissionStatus.denied (–ø–æ—Å–ª–µ –∑–∞–ø—Ä–æ—Å–∞)
/// —Å—á–∏—Ç–∞–µ—Ç—Å—è –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–º (–µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–Ω–æ –Ω–∞–∂–∞–ª "–û—Ç–∫–∞–∑–∞—Ç—å"),
/// –∏ –æ–∂–∏–¥–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ –ø—Ä–µ–∫—Ä–∞—â–∞–µ—Ç—Å—è. –ï—Å–ª–∏ false ‚Äì —Å—Ç–∞—Ç—É—Å denied –Ω–µ —Å—á–∏—Ç–∞–µ—Ç—Å—è –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–º,
/// –∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç –æ–ø—Ä–∞—à–∏–≤–∞—Ç—å —Å—Ç–∞—Ç—É—Å –¥–æ –∏—Å—Ç–µ—á–µ–Ω–∏—è —Ç–∞–π–º–∞—É—Ç–∞.
/// –í Android –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ "pending", –ø–æ—ç—Ç–æ–º—É —á–∞—Å—Ç–æ –ø–æ—Å–ª–µ –≤—ã–∑–æ–≤–∞ request()
/// —Å—Ç–∞—Ç—É—Å —Å—Ä–∞–∑—É —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è denied, –¥–∞–∂–µ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –µ—â—ë –Ω–µ –¥–∞–ª –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞.
const bool kTreatDeniedAsFinal = false;

class TimerPageState extends State<TimerPage> {
  // ValueNotifier –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞.
  final ValueNotifier<String> loadingStatus = ValueNotifier(
    "Initializing voice service...",
  );
  String currentLanguage = "en-US";
  // –§–ª–∞–≥, –ø–æ–ª—É—á–µ–Ω–æ –ª–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞.
  // (–ü—Ä–æ–≤–µ—Ä—è–µ–º —á–µ—Ä–µ–∑ Permission.microphone.status, –∞ request() –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å—Ä–∞–∑—É –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ)
  bool _micPermissionGranted = true;

  final FlutterTts flutterTts = FlutterTts();
  Timer? _uiTimer;
  Duration _accumulated = Duration.zero;
  DateTime? _startTime;
  DateTime? _lapStartTime;
  bool isActive = false;
  double volume = 1.0;
  int intervalSeconds = 30;
  // –û–ø—Ü–∏—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—É—é –º–æ–∂–Ω–æ –≤–∫–ª—é—á–∞—Ç—å/–≤—ã–∫–ª—é—á–∞—Ç—å —á–µ—Ä–µ–∑ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.
  bool voiceControlEnabled = true;
  // –§–ª–∞–≥ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è (–æ—Ç—Ä–∞–∂–∞–µ—Ç—Å—è –≤ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–µ).
  bool voiceRecognitionActive = false;
  bool immersiveModeEnabled = false;

  String? _displayedVoiceText;
  bool _displayedVoiceIsCommand = false;
  Timer? _clearVoiceTextTimer;
  int _lastIntervalAnnounced = -1;
  final List<LapRecord> _lapRecords = [];
  late VoiceCommandService voiceService;
  StreamSubscription<VoiceCommandResult>? _voiceSub;

  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â–µ–µ –≤—Ä–µ–º—è, —É—á–∏—Ç—ã–≤–∞—è –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è.
  Duration get elapsed {
    if (isActive && _startTime != null) {
      return _accumulated + DateTime.now().difference(_startTime!);
    }
    return _accumulated;
  }

  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º—è —Ç–µ–∫—É—â–µ–≥–æ –∫—Ä—É–≥–∞.
  Duration get currentLapElapsed {
    if (isActive && _lapStartTime != null) {
      return DateTime.now().difference(_lapStartTime!);
    }
    return Duration.zero;
  }

  /// –û–∂–∏–¥–∞–µ—Ç, –ø–æ–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –Ω–µ –±—É–¥–µ—Ç –≤—ã–¥–∞–Ω–æ.
  /// –ö–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É –æ–ø—Ä–∞—à–∏–≤–∞–µ—Ç —Å—Ç–∞—Ç—É—Å. –ï—Å–ª–∏ kTreatDeniedAsFinal==true –∏ —Å—Ç–∞—Ç—É—Å —Ä–∞–≤–µ–Ω denied,
  /// –∏–ª–∏ –µ—Å–ª–∏ —Å—Ç–∞—Ç—É—Å isPermanentlyDenied –∏–ª–∏ isRestricted, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç false.
  /// –ï—Å–ª–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –ø–æ–ª—É—á–µ–Ω–æ ‚Äì –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç true, –ª–∏–±–æ –∂–¥–µ—Ç –¥–æ –∏—Å—Ç–µ—á–µ–Ω–∏—è —Ç–∞–π–º–∞—É—Ç–∞.
  Future<bool> _waitForUserPermission(Duration timeout) async {
    final endTime = DateTime.now().add(timeout);
    while (DateTime.now().isBefore(endTime)) {
      final status = await Permission.microphone.status;
      if (status.isGranted) return true;
      if (kTreatDeniedAsFinal && status == PermissionStatus.denied)
        return false;
      if (status.isPermanentlyDenied || status.isRestricted) return false;
      await Future.delayed(const Duration(seconds: 1));
    }
    return false;
  }

  /// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–π —Å–µ—Ä–≤–∏—Å —Å –º–æ–¥–∞–ª—å–Ω—ã–º –æ–∫–Ω–æ–º.
  /// 1. –ó–∞–≥—Ä—É–∂–∞–µ—Ç —è–∑—ã–∫–æ–≤—É—é –º–æ–¥–µ–ª—å –∏ —Å–æ–∑–¥–∞–µ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç–µ–ª—å (initSpeechService: false),
  ///    —á—Ç–æ–±—ã –Ω–µ –∑–∞–ø—É—Å–∫–∞—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.
  /// 2. –ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ "Waiting for microphone permission...".
  /// 3. –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—Ç–∞—Ç—É—Å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è (–∑–∞–ø—Ä–æ—Å —É–∂–µ –±—ã–ª –≤—ã–∑–≤–∞–Ω –≤ initState).
  ///    –ï—Å–ª–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –≤—ã–¥–∞–Ω–æ ‚Äì –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å.
  ///    –ï—Å–ª–∏ —Å—Ç–∞—Ç—É—Å isPermanentlyDenied –∏–ª–∏ isRestricted (–∏–ª–∏, –µ—Å–ª–∏ kTreatDeniedAsFinal==true, —Ä–∞–≤–µ–Ω denied),
  ///    –∑–∞–∫—Ä—ã–≤–∞–µ—Ç –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –∏ –æ—Ç–∫–ª—é—á–∞–µ—Ç –æ–ø—Ü–∏—é –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è.
  ///    –ò–Ω–∞—á–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –æ–∂–∏–¥–∞–Ω–∏–µ —á–µ—Ä–µ–∑ _waitForUserPermission.
  Future<void> _initializeVoiceServiceWithModal() async {
    _showLoadingModelDialog();
    loadingStatus.value = "Initializing voice service...";
    try {
      // –ó–∞–≥—Ä—É–∂–∞–µ–º —è–∑—ã–∫–æ–≤—É—é –º–æ–¥–µ–ª—å –∏ —Å–æ–∑–¥–∞—ë–º —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç–µ–ª—å –±–µ–∑ –∑–∞–ø—É—Å–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞.
      await voiceService
          .initialize(loadingStatus: loadingStatus, initSpeechService: false)
          .timeout(kVoiceServiceTimeout);
      // –ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è.
      loadingStatus.value = "Waiting for microphone permission...";

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è (request() —É–∂–µ –±—ã–ª –≤—ã–∑–≤–∞–Ω –≤ initState).
      final micStatus = await Permission.microphone.status;
      if (micStatus.isGranted) {
        loadingStatus.value = "Starting speech service...";
        await voiceService.initializeSpeechService();
        Navigator.of(context).pop();
        await _startSpeechService();
      } else if (micStatus.isPermanentlyDenied ||
          micStatus.isRestricted ||
          (kTreatDeniedAsFinal && micStatus == PermissionStatus.denied)) {
        Navigator.of(context).pop();
        setState(() {
          voiceControlEnabled = false;
          voiceRecognitionActive = false;
        });
        appLog(
          "Microphone permission explicitly denied; voice service disabled.",
          name: "TimerPage",
        );
      } else {
        // –ï—Å–ª–∏ —Å—Ç–∞—Ç—É—Å —Ä–∞–≤–µ–Ω denied (–Ω–æ –Ω–µ permanentlyDenied), –Ω–∞—á–∏–Ω–∞–µ–º –æ–∂–∏–¥–∞–Ω–∏–µ.
        bool granted = await _waitForUserPermission(
          kVoicePermissionWaitTimeout,
        );
        Navigator.of(context).pop();
        if (granted) {
          loadingStatus.value = "Starting speech service...";
          await voiceService.initializeSpeechService();
          await _startSpeechService();
        } else {
          setState(() {
            voiceControlEnabled = false;
            voiceRecognitionActive = false;
          });
          appLog(
            "Microphone permission not granted within timeout; voice service disabled.",
            name: "TimerPage",
          );
        }
      }
    } catch (e) {
      loadingStatus.value = "Initialization failed: ${e.toString()}";
      appLog("Voice service initialization failed: $e", name: "TimerPage");
      await Future.delayed(const Duration(seconds: 2));
      Navigator.of(context).pop();
      setState(() {
        voiceRecognitionActive = false;
      });
    }
  }

  /// –ó–∞–ø—É—Å–∫–∞–µ—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏, –µ—Å–ª–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –≤—ã–¥–∞–Ω–æ.
  Future<void> _startSpeechService() async {
    loadingStatus.value = "Starting speech service...";
    final micStatus = await Permission.microphone.status;
    if (!micStatus.isGranted) {
      setState(() {
        voiceRecognitionActive = false;
      });
      appLog(
        "Microphone permission not granted; not starting speech service.",
        name: "TimerPage",
      );
      return;
    }
    try {
      await voiceService.startListening();
      setState(() {
        voiceRecognitionActive = true;
      });
      appLog("Speech service started.", name: "TimerPage");
    } catch (e, st) {
      appLog(
        "Error starting speech service: $e",
        name: "TimerPage",
        stackTrace: st,
      );
      await _restartSpeechService();
    }
  }

  /// –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç –≥–æ–ª–æ—Å–æ–≤–æ–π —Å–µ—Ä–≤–∏—Å.
  Future<void> _restartSpeechService() async {
    appLog("Restarting speech service...", name: "TimerPage");
    await _stopSpeechService();
    await Future.delayed(const Duration(seconds: 2));
    try {
      await voiceService.initialize(
        loadingStatus: loadingStatus,
        initSpeechService: false,
      );
      await voiceService.initializeSpeechService();
      await _startSpeechService();
      appLog("Speech service restarted.", name: "TimerPage");
    } catch (e, st) {
      appLog(
        "Error restarting speech service: $e",
        name: "TimerPage",
        stackTrace: st,
      );
    }
  }

  /// –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å, –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ—Å–≤–æ–±–æ–∂–¥–∞—è –µ–≥–æ —Ä–µ—Å—É—Ä—Å—ã.
  /// –ó–¥–µ—Å—å –º—ã –≤—ã–∑—ã–≤–∞–µ–º stopListening(), –∑–∞—Ç–µ–º freeSpeechService() –∏–∑ VoiceCommandService,
  /// —á—Ç–æ–±—ã –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —ç–∫–∑–µ–º–ø–ª—è—Ä SpeechService, –Ω–µ —É–Ω–∏—á—Ç–æ–∂–∞—è –ø–æ–ª–Ω–æ—Å—Ç—å—é VoiceCommandService.
  Future<void> _stopSpeechService() async {
    loadingStatus.value = "Stopping speech service...";
    try {
      // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ.
      await voiceService.stopListening();
      // –Ø–≤–Ω–æ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä SpeechService, –µ—Å–ª–∏ –º–µ—Ç–æ–¥ dispose() –¥–æ—Å—Ç—É–ø–µ–Ω.
      await voiceService.speechService?.dispose();
    } catch (e, st) {
      appLog(
        "Error stopping speech service: $e",
        name: "TimerPage",
        stackTrace: st,
      );
    }
    // –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–ª–∞–≥, —á—Ç–æ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –Ω–µ –∞–∫—Ç–∏–≤–Ω–æ.
    setState(() {
      voiceRecognitionActive = false;
    });
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–ª–µ speechService –≤ null,
    // —á—Ç–æ–±—ã —Å–ª–µ–¥—É—é—â–∏–π –≤—ã–∑–æ–≤ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–µ –≤—ã–∑—ã–≤–∞–ª –æ—à–∏–±–∫—É "instance already exist".
    voiceService.speechService = null;
    appLog("Speech service stopped and disposed.", name: "TimerPage");
  }

  /// –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–º –∑–∞–≥—Ä—É–∑–∫–∏/–æ–∂–∏–¥–∞–Ω–∏—è.
  Future<void> _showLoadingModelDialog() async {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder:
          (context) => AlertDialog(
            content: Row(
              children: [
                const CircularProgressIndicator(),
                const SizedBox(width: 10),
                Expanded(
                  child: ValueListenableBuilder<String>(
                    valueListenable: loadingStatus,
                    builder: (context, value, child) {
                      appLog("Loading status: $value", name: "UI STATUS");
                      return Text(value);
                    },
                  ),
                ),
              ],
            ),
          ),
    );
  }

  @override
  void initState() {
    super.initState();
    // –°—Ä–∞–∑—É –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –Ω–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ, —á—Ç–æ–±—ã —Å–∏—Å—Ç–µ–º–Ω—ã–π –¥–∏–∞–ª–æ–≥ –ø–æ—è–≤–∏–ª—Å—è –∫–∞–∫ –º–æ–∂–Ω–æ —Ä–∞–Ω—å—à–µ.
    Permission.microphone.request().then((status) {
      setState(() {
        _micPermissionGranted = status.isGranted;
      });
    });
    _loadSettings();
    // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Å–∏–Ω—Ç–µ–∑ —Ä–µ—á–∏.
    flutterTts.setLanguage(currentLanguage);
    flutterTts.setVolume(volume);
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–æ–ª–æ—Å–æ–≤–æ–π —Å–µ—Ä–≤–∏—Å.
    voiceService = VoiceCommandService();
    // –ü–æ—Å–ª–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è UI –∑–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞ —Å –º–æ–¥–∞–ª—å–Ω—ã–º –æ–∫–Ω–æ–º.
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      await _initializeVoiceServiceWithModal();
      // –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –ø–æ—Ç–æ–∫ –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥.
      _voiceSub = voiceService.commandStream.listen(
        (result) {
          setState(() {
            _displayedVoiceText = result.text;
            _displayedVoiceIsCommand = result.isCommand;
          });
          _clearVoiceTextTimer?.cancel();
          _clearVoiceTextTimer = Timer(const Duration(seconds: 3), () {
            setState(() {
              _displayedVoiceText = " ";
            });
          });
          if (result.isCommand) {
            _handleVoiceCommand(result.text);
          }
        },
        onError: (error) async {
          appLog("Speech service error: $error", name: "TimerPage");
          await _restartSpeechService();
        },
      );
      _maybeShowHelpDialog();
    });

    // UI-—Ç–∞–π–º–µ—Ä –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —ç–∫—Ä–∞–Ω–∞ –∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤.
    _uiTimer = Timer.periodic(const Duration(milliseconds: 50), (timer) {
      if (isActive && _startTime != null) {
        setState(() {});
        Duration currentElapsed = elapsed;
        int totalSeconds = currentElapsed.inSeconds;
        if (intervalSeconds != 0 &&
            totalSeconds > 0 &&
            totalSeconds % intervalSeconds == 0 &&
            totalSeconds != _lastIntervalAnnounced) {
          String announcement = _formatIntervalAnnouncement(currentElapsed);
          flutterTts.speak(announcement);
          _lastIntervalAnnounced = totalSeconds;
          appLog("Announced interval: $announcement", name: "TimerPage");
        }
      }
    });
  }

  /// –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –ø–æ–º–æ—â–∏ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ.
  Future<void> _maybeShowHelpDialog() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    bool helpShown = prefs.getBool('helpShown') ?? false;
    if (!helpShown) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _showHelpDialog();
      });
      await prefs.setBool('helpShown', true);
    }
  }

  /// –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É –¥–ª—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞.
  String _formatIntervalAnnouncement(Duration duration) {
    int totalSeconds = duration.inSeconds;
    int minutes = totalSeconds ~/ 60;
    int seconds = totalSeconds % 60;
    if (minutes > 0 && seconds == 0) {
      return "$minutes minute${minutes != 1 ? "s" : ""}";
    } else if (minutes > 0) {
      return "$minutes minute${minutes != 1 ? "s" : ""} and $seconds second${seconds != 1 ? "s" : ""}";
    } else {
      return "$seconds second${seconds != 1 ? "s" : ""}";
    }
  }

  /// –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –≤—Ä–µ–º—è –≤ —Å—Ç—Ä–æ–∫—É —Ñ–æ—Ä–º–∞—Ç–∞ MM:SS:CC.
  String _formatTime(Duration duration) {
    int minutes = duration.inMinutes;
    int seconds = duration.inSeconds % 60;
    int centiseconds = ((duration.inMilliseconds % 1000) / 10).floor();
    return "${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}:${centiseconds.toString().padLeft(2, '0')}";
  }

  /// –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –≤—Ä–µ–º—è –¥–ª—è –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏—è (–±–µ–∑ —Å–æ—Ç—ã—Ö).
  String _formatAnnouncement(Duration duration) {
    int minutes = duration.inMinutes;
    int seconds = duration.inSeconds % 60;
    if (minutes > 0) {
      return "$minutes minute${minutes != 1 ? "s" : ""} and $seconds second${seconds != 1 ? "s" : ""}";
    } else {
      return "$seconds second${seconds != 1 ? "s" : ""}";
    }
  }

  /// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É –∑–∞–ø–∏—Å–∏ –∫—Ä—É–≥–∞.
  void _handleLap() {
    if (isActive && _lapStartTime != null) {
      Duration currentLap = DateTime.now().difference(_lapStartTime!);
      Duration overall = elapsed;
      int lapNumber = _lapRecords.length + 1;
      flutterTts.speak("circle $lapNumber");
      LapRecord lapRecord = LapRecord(
        lapNumber: lapNumber,
        lapTime: currentLap,
        overallTime: overall,
      );
      _lapRecords.insert(0, lapRecord);
      _lapStartTime = DateTime.now();
      appLog(
        "Lap recorded: Circle $lapNumber, lap time: $currentLap, overall: $overall",
        name: "TimerPage",
      );
      setState(() {});
    }
  }

  /// –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≥–æ–ª–æ—Å–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã, –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –æ—Ç —Å–µ—Ä–≤–∏—Å–∞.
  void _handleVoiceCommand(String commandText) {
    appLog("Voice command received: $commandText", name: "TimerPage");
    if (commandText.contains("start") ||
        commandText.contains("go") ||
        commandText.contains("begin") ||
        commandText.contains("resume")) {
      if (!isActive) {
        flutterTts.speak("Stopwatch started");
        setState(() {
          isActive = true;
          _startTime = DateTime.now();
          _lapStartTime = DateTime.now();
        });
        appLog(
          "Voice command executed: start/go/begin/resume",
          name: "TimerPage",
        );
      }
    } else if (commandText.contains("stop") || commandText.contains("pause")) {
      if (isActive && _startTime != null) {
        Duration currentRun = DateTime.now().difference(_startTime!);
        Duration total = _accumulated + currentRun;
        final formatted = _formatAnnouncement(total);
        flutterTts.speak("completed $formatted");
        setState(() {
          isActive = false;
          _accumulated = total;
          _startTime = null;
        });
        appLog("Voice command executed: stop/pause", name: "TimerPage");
      }
    } else if (commandText.contains("lap") || commandText.contains("split")) {
      if (isActive && _lapStartTime != null) {
        _handleLap();
      }
    } else if (commandText.contains("reset") ||
        commandText.contains("clear") ||
        commandText.contains("restart") ||
        commandText.contains("renew")) {
      flutterTts.speak("Stopwatch in zero");
      setState(() {
        isActive = false;
        _accumulated = Duration.zero;
        _startTime = null;
        _lapStartTime = null;
        _lapRecords.clear();
      });
      appLog(
        "Voice command executed: reset/clear/restart/renew",
        name: "TimerPage",
      );
    }
  }

  /// –ó–∞–≥—Ä—É–∂–∞–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (–≥—Ä–æ–º–∫–æ—Å—Ç—å, –∏–Ω—Ç–µ—Ä–≤–∞–ª, –≥–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ, immersive mode).
  Future<void> _loadSettings() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    setState(() {
      volume = prefs.getDouble('volume') ?? 1.0;
      intervalSeconds = prefs.getInt('intervalSeconds') ?? 30;
      voiceControlEnabled = prefs.getBool('voiceControlEnabled') ?? true;
      immersiveModeEnabled = prefs.getBool('immersiveMode') ?? false;
    });
    flutterTts.setVolume(volume);
  }

  /// –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.
  Future<void> _saveSettings() async {
    SharedPreferences prefs = await SharedPreferences.getInstance();
    await prefs.setDouble('volume', volume);
    await prefs.setInt('intervalSeconds', intervalSeconds);
    await prefs.setBool('voiceControlEnabled', voiceControlEnabled);
    await prefs.setBool('immersiveMode', immersiveModeEnabled);
  }

  /// –í–∏–¥–∂–µ—Ç —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–Ω–æ–ø–æ–∫ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è –ª–∞–Ω–¥—à–∞—Ñ—Ç–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞).
  Widget _buildFixedButtons() {
    return Container(
      height: 80,
      padding: const EdgeInsets.only(top: 8),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          _buildLapOrResetButton(),
          const SizedBox(width: 20),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              minimumSize: const Size(150, 60),
              shape: const StadiumBorder(),
              backgroundColor: Colors.green,
              foregroundColor: Colors.white,
            ),
            onPressed: () {
              if (!isActive) {
                flutterTts.speak('Stopwatch started');
                setState(() {
                  isActive = true;
                  _startTime = DateTime.now();
                  _lapStartTime = DateTime.now();
                });
                appLog("Manual: Stopwatch started", name: "TimerPage");
              } else if (isActive && _startTime != null) {
                Duration currentRun = DateTime.now().difference(_startTime!);
                Duration total = _accumulated + currentRun;
                final formatted = _formatAnnouncement(total);
                flutterTts.speak("completed $formatted");
                setState(() {
                  isActive = false;
                  _accumulated = total;
                  _startTime = null;
                });
                appLog("Manual: Stopwatch stopped", name: "TimerPage");
              }
            },
            child: Text(
              isActive
                  ? 'Stop'
                  : (elapsed > Duration.zero ? 'Resume' : 'Start'),
            ),
          ),
        ],
      ),
    );
  }

  /// –í–∏–¥–∂–µ—Ç —Ç–∞–±–ª–∏—Ü—ã –∑–∞–ø–∏—Å–µ–π –∫—Ä—É–≥–æ–≤.
  Widget _buildLapTable() {
    return Expanded(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Container(
            padding: const EdgeInsets.symmetric(vertical: 8),
            decoration: const BoxDecoration(
              border: Border(bottom: BorderSide(color: Colors.white, width: 1)),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: const [
                Expanded(
                  child: Text(
                    "Lap",
                    style: TextStyle(fontSize: 18),
                    textAlign: TextAlign.center,
                  ),
                ),
                Expanded(
                  child: Text(
                    "Lap times",
                    style: TextStyle(fontSize: 18),
                    textAlign: TextAlign.center,
                  ),
                ),
                Expanded(
                  child: Text(
                    "Overall time",
                    style: TextStyle(fontSize: 18),
                    textAlign: TextAlign.center,
                  ),
                ),
              ],
            ),
          ),
          Expanded(
            child: SingleChildScrollView(
              child: Column(
                children: List.generate(_lapRecords.length, (index) {
                  final lap = _lapRecords[index];
                  return Padding(
                    padding: const EdgeInsets.symmetric(vertical: 8),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Expanded(
                          child: Text(
                            lap.lapNumber.toString(),
                            style: const TextStyle(fontSize: 18),
                            textAlign: TextAlign.center,
                          ),
                        ),
                        Expanded(
                          child: Text(
                            _formatTime(lap.lapTime),
                            style: const TextStyle(fontSize: 18),
                            textAlign: TextAlign.center,
                          ),
                        ),
                        Expanded(
                          child: Text(
                            _formatTime(lap.overallTime),
                            style: const TextStyle(fontSize: 18),
                            textAlign: TextAlign.center,
                          ),
                        ),
                      ],
                    ),
                  );
                }),
              ),
            ),
          ),
          const SizedBox(height: 16),
        ],
      ),
    );
  }

  /// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–Ω–æ–ø–∫—É "Lap" (–µ—Å–ª–∏ —Ç–∞–π–º–µ—Ä –∞–∫—Ç–∏–≤–µ–Ω) –∏–ª–∏ "Reset" (–µ—Å–ª–∏ —Ç–∞–π–º–µ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω).
  Widget _buildLapOrResetButton() {
    if (isActive) {
      return ElevatedButton(
        style: ElevatedButton.styleFrom(
          minimumSize: const Size(150, 60),
          shape: const StadiumBorder(),
          backgroundColor: Colors.blue,
          foregroundColor: Colors.white,
        ),
        onPressed: _handleLap,
        child: const Text('Lap'),
      );
    } else {
      if (elapsed > Duration.zero) {
        return ElevatedButton(
          style: ElevatedButton.styleFrom(
            minimumSize: const Size(150, 60),
            shape: const StadiumBorder(),
            backgroundColor: Colors.red,
            foregroundColor: Colors.white,
          ),
          onPressed: _handleReset,
          child: const Text('Reset'),
        );
      } else {
        return ElevatedButton(
          style: ElevatedButton.styleFrom(
            minimumSize: const Size(150, 60),
            shape: const StadiumBorder(),
            backgroundColor: Colors.grey,
            foregroundColor: Colors.white,
          ),
          onPressed: null,
          child: const Text('Lap'),
        );
      }
    }
  }

  /// –°–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Ç–∞–π–º–µ—Ä –∏ –æ—á–∏—â–∞–µ—Ç –∑–∞–ø–∏—Å–∏.
  void _handleReset() {
    flutterTts.speak("Stopwatch in zero");
    setState(() {
      isActive = false;
      _accumulated = Duration.zero;
      _startTime = null;
      _lapStartTime = null;
      _lapRecords.clear();
    });
    appLog("Manual: Stopwatch reset", name: "TimerPage");
  }

  @override
  void dispose() {
    _uiTimer?.cancel();
    _voiceSub?.cancel();
    _clearVoiceTextTimer?.cancel();
    voiceService.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final orientation = MediaQuery.of(context).orientation;
    Widget bodyContent;

    if (orientation == Orientation.portrait || _lapRecords.isEmpty) {
      Widget upperGroup;
      if (_lapRecords.isEmpty) {
        upperGroup = Container(
          height: MediaQuery.of(context).size.height * 0.33,
          alignment: Alignment.bottomCenter,
          child: Text(
            _formatTime(elapsed),
            style: const TextStyle(fontSize: 80, color: Colors.white),
          ),
        );
        upperGroup = Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            upperGroup,
            const SizedBox(height: 0),
            Icon(
              voiceRecognitionActive ? Icons.mic : Icons.mic_off,
              color: voiceRecognitionActive ? Colors.green : Colors.red,
              size: 40,
            ),
            const SizedBox(height: 8),
            SizedBox(
              height: 20,
              child: Center(
                child: Text(
                  _displayedVoiceText ?? " ",
                  style: TextStyle(
                    fontSize: 16,
                    color:
                        _displayedVoiceIsCommand ? Colors.green : Colors.orange,
                    fontWeight:
                        _displayedVoiceIsCommand
                            ? FontWeight.bold
                            : FontWeight.normal,
                  ),
                ),
              ),
            ),
          ],
        );
      } else {
        upperGroup = Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Text(
              _formatTime(elapsed),
              style: const TextStyle(fontSize: 80, color: Colors.white),
            ),
            if (isActive && _lapStartTime != null)
              Text(
                _formatTime(DateTime.now().difference(_lapStartTime!)),
                style: const TextStyle(fontSize: 40, color: Colors.white70),
              ),
            const SizedBox(height: 0),
            Icon(
              voiceRecognitionActive ? Icons.mic : Icons.mic_off,
              color: voiceRecognitionActive ? Colors.green : Colors.red,
              size: 40,
            ),
            const SizedBox(height: 10),
            SizedBox(
              height: 20,
              child: Center(
                child: Text(
                  _displayedVoiceText ?? " ",
                  style: TextStyle(
                    fontSize: 16,
                    color:
                        _displayedVoiceIsCommand ? Colors.green : Colors.orange,
                    fontWeight:
                        _displayedVoiceIsCommand
                            ? FontWeight.bold
                            : FontWeight.normal,
                  ),
                ),
              ),
            ),
            const SizedBox(height: 10),
            _buildLapTable(),
          ],
        );
      }
      bodyContent = Column(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Expanded(child: upperGroup),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              _buildLapOrResetButton(),
              const SizedBox(width: 20),
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                  minimumSize: const Size(150, 60),
                  shape: const StadiumBorder(),
                  backgroundColor: Colors.green,
                  foregroundColor: Colors.white,
                ),
                onPressed: () {
                  if (!isActive) {
                    flutterTts.speak('Stopwatch started');
                    setState(() {
                      isActive = true;
                      _startTime = DateTime.now();
                      _lapStartTime = DateTime.now();
                    });
                    appLog("Manual: Stopwatch started", name: "TimerPage");
                  } else if (isActive && _startTime != null) {
                    Duration currentRun = DateTime.now().difference(
                      _startTime!,
                    );
                    Duration total = _accumulated + currentRun;
                    final formatted = _formatAnnouncement(total);
                    flutterTts.speak("completed $formatted");
                    setState(() {
                      isActive = false;
                      _accumulated = total;
                      _startTime = null;
                    });
                    appLog("Manual: Stopwatch stopped", name: "TimerPage");
                  }
                },
                child: Text(
                  isActive
                      ? 'Stop'
                      : (elapsed > Duration.zero ? 'Resume' : 'Start'),
                ),
              ),
            ],
          ),
        ],
      );
    } else {
      Widget leftColumn = Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Text(
            _formatTime(elapsed),
            style: const TextStyle(fontSize: 60, color: Colors.white),
          ),
          if (isActive && _lapStartTime != null)
            Text(
              _formatTime(DateTime.now().difference(_lapStartTime!)),
              style: const TextStyle(
                fontSize: 30,
                color: Colors.white70,
                height: 0.8,
              ),
            ),
          const SizedBox(height: 0),
          Icon(
            voiceRecognitionActive ? Icons.mic : Icons.mic_off,
            color: voiceRecognitionActive ? Colors.green : Colors.red,
            size: 30,
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 20,
            child: Center(
              child: Text(
                _displayedVoiceText ?? " ",
                style: TextStyle(
                  fontSize: 14,
                  color:
                      _displayedVoiceIsCommand ? Colors.green : Colors.orange,
                  fontWeight:
                      _displayedVoiceIsCommand
                          ? FontWeight.bold
                          : FontWeight.normal,
                ),
              ),
            ),
          ),
          const Spacer(),
          _buildFixedButtons(),
        ],
      );
      Widget rightColumn = _buildLapTable();
      bodyContent = Row(
        children: [
          Expanded(child: leftColumn),
          const SizedBox(width: 20),
          Expanded(child: rightColumn),
        ],
      );
    }

    return WillPopScope(
      onWillPop: () async {
        final bool exitConfirmed =
            await showDialog<bool>(
              context: context,
              builder:
                  (BuildContext context) => AlertDialog(
                    title: const Text("Confirm exit"),
                    content: const Text("Do you really want to exit the app?"),
                    actions: <Widget>[
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(false),
                        child: const Text("No"),
                      ),
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(true),
                        child: const Text("Yes"),
                      ),
                    ],
                  ),
            ) ??
            false;
        return exitConfirmed;
      },
      child: Scaffold(
        appBar: AppBar(
          title: const Text('VoiceControl Stopwatch'),
          backgroundColor: const Color(0xFF001F3F),
          actions: [
            IconButton(
              icon: const Icon(Icons.help_outline),
              onPressed: _showHelpDialog,
            ),
            IconButton(
              icon: const Icon(Icons.settings),
              onPressed: () {
                showModalBottomSheet(
                  context: context,
                  isScrollControlled: true,
                  builder: (context) => SettingsPage(state: this),
                );
              },
            ),
          ],
        ),
        backgroundColor: const Color(0xFF001F3F),
        body: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
          child: bodyContent,
        ),
      ),
    );
  }

  /// –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ —Å–ø—Ä–∞–≤–∫–∏.
  void _showHelpDialog() {
    showDialog(
      context: context,
      barrierDismissible: true,
      builder: (context) {
        return AlertDialog(
          title: const Text(
            "Help",
            style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
          content: SizedBox(
            width: double.maxFinite,
            child: SingleChildScrollView(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: const [
                  Text(
                    "Available Voice Commands:",
                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  SizedBox(height: 8),
                  Text(
                    "- Start / Go / Begin / Resume: Start or resume the stopwatch.",
                  ),
                  Text(
                    "- Stop / Pause: Stop the stopwatch and announce the elapsed time.",
                  ),
                  Text(
                    "- Lap / Split: Record the current lap time and overall time.",
                  ),
                  Text(
                    "- Reset / Clear / Restart / Renew: Reset the stopwatch to zero.",
                  ),
                  SizedBox(height: 16),
                  Text(
                    "About the App:",
                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  SizedBox(height: 8),
                  Text(
                    "This is a VoiceControl Stopwatch app. You can control the stopwatch with voice commands.",
                  ),
                  SizedBox(height: 16),
                  Text(
                    "Requirements:",
                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  SizedBox(height: 8),
                  Text("Android version 11 or higher is required."),
                  SizedBox(height: 16),
                  Text(
                    "Licenses:",
                    style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                  ),
                  SizedBox(height: 8),
                  Text("Components are used under the Apache 2.0 License."),
                ],
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text("Close"),
            ),
          ],
        );
      },
    );
  }
}

class SettingsPage extends StatefulWidget {
  final TimerPageState state;
  const SettingsPage({super.key, required this.state});
  @override
  SettingsPageState createState() => SettingsPageState();
}

class SettingsPageState extends State<SettingsPage> {
  @override
  Widget build(BuildContext context) {
    final intervalOptions = <DropdownMenuItem<int>>[
      const DropdownMenuItem(value: 0, child: Text("Disable")),
      const DropdownMenuItem(value: 10, child: Text("10 Seconds")),
      const DropdownMenuItem(value: 20, child: Text("20 Seconds")),
      const DropdownMenuItem(value: 30, child: Text("30 Seconds")),
      const DropdownMenuItem(value: 60, child: Text("1 Minute")),
      const DropdownMenuItem(value: 300, child: Text("5 Minutes")),
      const DropdownMenuItem(value: 600, child: Text("10 Minutes")),
    ];
    return Scaffold(
      appBar: PreferredSize(
        preferredSize: const Size.fromHeight(kToolbarHeight + 20),
        child: SafeArea(
          child: Padding(
            padding: const EdgeInsets.only(top: 20),
            child: AppBar(
              title: const Text("Settings"),
              backgroundColor: const Color(0xFF001F3F),
              leading: Padding(
                padding: const EdgeInsets.only(top: 10),
                child: IconButton(
                  icon: const Icon(Icons.arrow_back),
                  onPressed: () => Navigator.pop(context),
                ),
              ),
              actions: [
                Padding(
                  padding: const EdgeInsets.only(top: 10),
                  child: IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: () => Navigator.pop(context),
                  ),
                ),
              ],
              toolbarHeight: kToolbarHeight + 20,
            ),
          ),
        ),
      ),
      backgroundColor: const Color(0xFF001F3F),
      body: SafeArea(
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            ListTile(
              title: const Text('Volume Control'),
              subtitle: Slider(
                value: widget.state.volume,
                min: 0.0,
                max: 1.0,
                divisions: 10,
                label: "${(widget.state.volume * 100).toInt()}%",
                onChanged: (double value) {
                  setState(() {
                    widget.state.volume = value;
                    widget.state.flutterTts.setVolume(value);
                    widget.state._saveSettings();
                  });
                },
              ),
            ),
            ListTile(
              title: const Text('Speech Interval'),
              trailing: DropdownButton<int>(
                value: widget.state.intervalSeconds,
                items: intervalOptions,
                onChanged: (int? newValue) {
                  if (newValue != null) {
                    setState(() {
                      widget.state.intervalSeconds = newValue;
                      widget.state._saveSettings();
                    });
                  }
                },
              ),
            ),
            SwitchListTile(
              title: const Text('Voice Control'),
              value: widget.state.voiceControlEnabled,
              onChanged: (bool value) async {
                if (value) {
                  // –ü—Ä–∏ –≤–∫–ª—é—á–µ–Ω–∏–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.
                  PermissionStatus status = await Permission.microphone.status;
                  if (status.isPermanentlyDenied) {
                    // –ï—Å–ª–∏ —Å—Ç–∞—Ç—É—Å permanentlyDenied, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥ —Å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ–º –ø–µ—Ä–µ–π—Ç–∏ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.
                    final shouldOpenSettings = await showDialog<bool>(
                      context: context,
                      builder:
                          (context) => AlertDialog(
                            title: const Text(
                              "Microphone permission not granted",
                            ),
                            content: const Text(
                              "To use voice control, please allow microphone access in the app settings.",
                            ),
                            actions: [
                              TextButton(
                                onPressed:
                                    () => Navigator.of(context).pop(false),
                                child: const Text("Cancel"),
                              ),
                              TextButton(
                                onPressed:
                                    () => Navigator.of(context).pop(true),
                                child: const Text("Open Settings"),
                              ),
                            ],
                          ),
                    );
                    if (shouldOpenSettings == true) {
                      await openAppSettings();
                    }
                    setState(() {
                      widget.state.voiceControlEnabled = false;
                      widget.state.voiceRecognitionActive = false;
                    });
                    await widget.state._saveSettings();
                    return;
                  } else {
                    final newStatus = await Permission.microphone.request();
                    if (!newStatus.isGranted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text(
                            "Microphone permission not granted. Voice recognition disabled.",
                          ),
                        ),
                      );
                      setState(() {
                        widget.state.voiceControlEnabled = false;
                        widget.state.voiceRecognitionActive = false;
                      });
                      await widget.state._saveSettings();
                      return;
                    }
                  }
                  // –ü–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Å–µ—Ä–≤–∏—Å.
                  await widget.state._stopSpeechService();
                  setState(() {
                    widget.state.voiceControlEnabled = true;
                  });
                  await widget.state._saveSettings();
                  appLog(
                    "Voice control enabled. Starting initialization...",
                    name: "SettingsPage",
                  );
                  widget.state
                      ._initializeVoiceServiceWithModal()
                      .then((_) {
                        appLog(
                          "Voice service started via settings.",
                          name: "SettingsPage",
                        );
                      })
                      .catchError((error, stackTrace) {
                        appLog(
                          "Error during voice service initialization: $error",
                          name: "SettingsPage",
                          stackTrace: stackTrace,
                        );
                      });
                } else {
                  // –ü—Ä–∏ –≤—ã–∫–ª—é—á–µ–Ω–∏–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–µ—Ä–≤–∏—Å.
                  setState(() {
                    widget.state.voiceControlEnabled = false;
                  });
                  await widget.state._saveSettings();
                  appLog(
                    "Voice control disabled. Stopping voice service...",
                    name: "SettingsPage",
                  );
                  widget.state
                      ._stopSpeechService()
                      .then((_) {
                        appLog(
                          "Voice service stopped via settings.",
                          name: "SettingsPage",
                        );
                      })
                      .catchError((error, stackTrace) {
                        appLog(
                          "Error stopping voice service: $error",
                          name: "SettingsPage",
                          stackTrace: stackTrace,
                        );
                      });
                }
              },
            ),
            SwitchListTile(
              title: const Text("Full screen mode"),
              value: widget.state.immersiveModeEnabled,
              onChanged: (bool value) {
                setState(() {
                  widget.state.immersiveModeEnabled = value;
                });
                widget.state._saveSettings();
                WidgetsBinding.instance.addPostFrameCallback((_) {
                  Flushbar(
                    message:
                        "The new display mode will take effect after restarting the app.",
                    duration: const Duration(seconds: 2),
                    margin: const EdgeInsets.all(12),
                    borderRadius: BorderRadius.circular(8),
                    backgroundColor: Colors.black87,
                    flushbarPosition: FlushbarPosition.BOTTOM,
                  ).show(context);
                });
              },
            ),
          ],
        ),
      ),
    );
  }
}
